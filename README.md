## What is functionish programming?

Loosely based on functional programming, functionish programming combines a set of general best practices with a subset
of functional programming core concepts. Why just a subset? Partly because so much of functional programming is
incomprehensible to those of us without a PhD in lambda calculus, but mostly just because a subset is all that you need
to write responsible, readable, maintainable, high-quality code. Well, that and Javascript, of course.

## Why Javascript?

The 'function' in functionish refers to functional programming while '-ish' reflects the rather loose and pragmatic
interpretation of functional programming that functionish programming is all about. But once you choose to go ishy,
there really is no better programming language to choose than Javascript. Ishiness is to Javascript what the oxygen is
to the air we breathe.

For starters, the language somewhat looks like and certainly sounds like Java, but it's not. How *ish*y is that?
Especially since Javascript's author originally intended it to be Scheme-*ish*. Then there's all that boolishness with
Javascript truthy and falsy values. And how about Javascript arrays: they look like arrays and act like arrays, but
they're not really arrays - that's some unabashed *ish*iness right there, that is. Then there's Javascript's standard
for testing equality, a remarkably loose standard that really requires no more than a vague resemblance. And I haven't
even mentioned Javascript classes yet - mostly because in general I prefer not to mention Javascript
classes unless I really, really have to. If you add higher-order functions and closures to the mix, what you end up with
is the ideal language for functionish programming.

That doesn't mean that you can't do functionish programming with other programming languages. You certainly can. It's
just that Javascript and functionish programming are a perfect fit. With Javascript you get ishiness right out of
the box. No configuration required.

## What about TypeScript?

No, no, no, no, and no. No types, no TypeScript. If you're a TypeScript devotee, chances are you're actually a closet
Java-lover and you just don't know it. Not that there's anything wrong with that per s√©. Many functionish
programmers I know have one or two Java-lovers among their friends. Maybe not their best friends, but still.
Any many of us have our own personal history with Java, even if we don't often like to talk about it, including yours
truly. So don't think that I don't understand the appeal of TypeScript.

But here's the thing: there are no bugs in your code that a type-safe compiler can catch at compile time that can't be
protected against just as effectively by well-written code based on sound programming principles and combined with
a disciplined testing regime. None, zero, nada, niente, nichts. For all the extra effort that TypeScript requires and
the added code complexity that TypeScript brings to the table, the opportunity cost of writing TypeScript code
outweighs it's modest benefits many times over.

Now, there's nothing wrong with types, and certainly types have their place in functional programming as well.
So feel free to experiment with functionish programming in TypeScript, if that's your thing. Just be prepared for a lot
of generics littered throughout your code. Not really my cup of tea.

## Is functionish programming difficult?

Yes and no. Certainly, the level of abstraction inherent to many functional programming concepts such as functors and
monads and combinators and what-not is so high that your average functionish programmer with a mere above-average IQ
stands little to no chance of really coming to terms with them.

But the thing with functionish programming is that you don't have to know all those things. We just `map()` and we
`curry()` and we `compose()` and we `id()` and so on and we do so with pure-*ish* functions and immutable-*ish* state...
and we leave it at that. No need to get all highfalutin or academic about it. Is that a P-combinator you're lifting
into that monoid there or are you just happy to see me?

So in that sense, functionish programming is not especially difficult. Certainly not like functional programming and
the John Nash mental predisposition it seems to favor. At the same time, though, functionish programming is about more
than just `map()` and `curry()` and so on. It's about exploiting higher order functions and closures and what-not to
their maximum potential, and that requires insight, real insight, which in turn requires practice.

But not to worry, you don't need to know all those things to start reaping the benefits of functionish programming.
Functionish programming is more than just functional constructs. It also comprises a set of best practices that alone
will go a long way towards making your code more reliable, more readable and more maintainable, so all in all more
better. And these best practices certainly aren't hard, not at all, other than that they might you to unlearn some very
stubborn habits that you may have acquired over the years.

## What about performance?

What about performance, you ask? Yawn. What about it?

Look, for sure functionish programming's reliance on abundant functions and function composition and purity and
immutability and so on results in code that is less performant than its imperative or even object-oriented
counterparts. But it's not a question of which programming paradigm is more performant. The question is: what
difference does it make?

Have you ever read those performance tests that folks will debate about on Stack Overflow? They'll take an array with
100,000 items and loop over it a million times only to conclude that a `while`-loop achieves 23,000 iterations per
second while `Array.forEach()` bares reaches 20,000 iterations Are you f*ing kidding me?

If you take issue with such measurement results, than maybe functionish programming isn't for you. But unless you're
designing the guidance system for SpaceX's new space rocket or a priority task scheduler for the CERN Large Hadron
Collider, chances are any performance issues you encounter will not be related to your chosen programming
paradigm. At least not in my personal experience, and I should know. I've underperformed all my life, and other than a
latent inferiority complex I'm none the worse for it.

And guess what: if you do run into performance issues in a hot code path and you believe the functionish code is the
source of your problems, by all means, feel free to revert to imperative code. I doubt it will really make much of a
difference, but functionish programming is all about being pragmatic, not orthodox. 

## So what exactly is functionish programming?

1. Be pure, but not a purist
2. Immutable, but not inflexible
3. Closures not classes
4. The three C's of functionish programming: Curry, Compose and map-reduCe
5. Size does make a difference
6. A good one-liner really says it all
7. Everything is in a name
8. Ternary: yes or no?
9. It's easier to be a simpleton than a smart-ass
10. This gets our panties in a twist
11. The maintainer always comes first
12. Imperative is not a dirty word

